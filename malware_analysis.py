#!/usr/bin/env python3
"""
Malware Analysis Tools - Инструменты анализа вредоносного ПО (только для CTF)
"""

import argparse
import sys
import os
import hashlib
import base64
import json
import struct
try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False
    print_warning("pefile не установлен - PE анализ недоступен")

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    print_warning("yara-python не установлен - YARA сканирование недоступно")
from datetime import datetime
from typing import List, Dict, Optional, Tuple
from utils import *

class PEAnalyzer:
    """Анализатор PE файлов"""
    
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.pe = None
        self.analysis_result = {}
        
        if not os.path.exists(filepath):
            print_error(f"Файл не найден: {filepath}")
            sys.exit(1)
    
    def analyze_pe(self) -> Dict:
        """Полный анализ PE файла"""
        if not PEFILE_AVAILABLE:
            print_error("PE анализ недоступен - установите pefile")
            return {}
            
        print_info(f"Анализ PE файла: {self.filepath}")
        
        try:
            self.pe = pefile.PE(self.filepath)
            self.analysis_result = {
                'file_info': self._get_file_info(),
                'sections': self._analyze_sections(),
                'imports': self._analyze_imports(),
                'exports': self._analyze_exports(),
                'strings': self._extract_strings(),
                'entropy': self._calculate_entropy(),
                'suspicious_features': self._detect_suspicious_features()
            }
            
            print_success("PE анализ завершен")
            return self.analysis_result
            
        except Exception as e:
            print_error(f"Ошибка анализа PE: {e}")
            return {}
    
    def _get_file_info(self) -> Dict:
        """Получение информации о файле"""
        info = {
            'filename': os.path.basename(self.filepath),
            'size': os.path.getsize(self.filepath),
            'machine': hex(self.pe.FILE_HEADER.Machine),
            'timestamp': datetime.fromtimestamp(self.pe.FILE_HEADER.TimeDateStamp).strftime('%Y-%m-%d %H:%M:%S'),
            'entry_point': hex(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint),
            'image_base': hex(self.pe.OPTIONAL_HEADER.ImageBase),
            'subsystem': self.pe.OPTIONAL_HEADER.Subsystem
        }
        
        print_success(f"Файл: {info['filename']}")
        print_success(f"Размер: {info['size']} bytes")
        print_success(f"Точка входа: {info['entry_point']}")
        
        return info
    
    def _analyze_sections(self) -> List[Dict]:
        """Анализ секций PE файла"""
        sections = []
        
        for section in self.pe.sections:
            section_info = {
                'name': section.Name.decode().rstrip('\x00'),
                'virtual_address': hex(section.VirtualAddress),
                'virtual_size': hex(section.Misc_VirtualSize),
                'raw_size': hex(section.SizeOfRawData),
                'characteristics': hex(section.Characteristics),
                'entropy': self._calculate_section_entropy(section)
            }
            sections.append(section_info)
        
        print_success(f"Найдено секций: {len(sections)}")
        return sections
    
    def _analyze_imports(self) -> List[Dict]:
        """Анализ импортов"""
        imports = []
        
        if hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode()
                functions = []
                
                for imp in entry.imports:
                    if imp.name:
                        functions.append(imp.name.decode())
                
                imports.append({
                    'dll': dll_name,
                    'functions': functions,
                    'function_count': len(functions)
                })
        
        print_success(f"Найдено импортов: {len(imports)}")
        return imports
    
    def _analyze_exports(self) -> List[Dict]:
        """Анализ экспортов"""
        exports = []
        
        if hasattr(self.pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in self.pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if exp.name:
                    exports.append({
                        'name': exp.name.decode(),
                        'ordinal': exp.ordinal,
                        'address': hex(exp.address)
                    })
        
        print_success(f"Найдено экспортов: {len(exports)}")
        return exports
    
    def _extract_strings(self, min_length: int = 4) -> List[str]:
        """Извлечение строк из файла"""
        strings = []
        
        try:
            with open(self.filepath, 'rb') as f:
                data = f.read()
            
            current_string = ""
            for byte in data:
                if 32 <= byte <= 126:  # Печатные ASCII символы
                    current_string += chr(byte)
                else:
                    if len(current_string) >= min_length:
                        strings.append(current_string)
                    current_string = ""
            
            # Добавляем последнюю строку
            if len(current_string) >= min_length:
                strings.append(current_string)
        
        except Exception as e:
            print_error(f"Ошибка извлечения строк: {e}")
        
        print_success(f"Найдено строк: {len(strings)}")
        return strings[:100]  # Ограничиваем количество
    
    def _calculate_entropy(self) -> float:
        """Вычисление энтропии файла"""
        try:
            with open(self.filepath, 'rb') as f:
                data = f.read()
            
            # Подсчет частоты байтов
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Вычисление энтропии
            entropy = 0
            data_len = len(data)
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * math.log2(probability)
            
            return entropy
            
        except Exception as e:
            print_error(f"Ошибка вычисления энтропии: {e}")
            return 0.0
    
    def _calculate_section_entropy(self, section) -> float:
        """Вычисление энтропии секции"""
        try:
            data = section.get_data()
            
            # Подсчет частоты байтов
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Вычисление энтропии
            entropy = 0
            data_len = len(data)
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * math.log2(probability)
            
            return entropy
            
        except:
            return 0.0
    
    def _detect_suspicious_features(self) -> List[str]:
        """Обнаружение подозрительных особенностей"""
        suspicious = []
        
        # Проверка подозрительных импортов
        suspicious_imports = [
            'VirtualAlloc', 'VirtualProtect', 'CreateProcess',
            'WriteProcessMemory', 'ReadProcessMemory', 'SetWindowsHookEx',
            'RegSetValue', 'RegCreateKey', 'InternetOpen', 'URLDownloadToFile'
        ]
        
        if hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name and imp.name.decode() in suspicious_imports:
                        suspicious.append(f"Suspicious import: {imp.name.decode()}")
        
        # Проверка высокого уровня энтропии
        if self._calculate_entropy() > 7.5:
            suspicious.append("High entropy - possible packed/encrypted content")
        
        # Проверка подозрительных секций
        for section in self.pe.sections:
            section_name = section.Name.decode().rstrip('\x00')
            if section_name in ['.rsrc', '.data'] and self._calculate_section_entropy(section) > 7.0:
                suspicious.append(f"High entropy in section: {section_name}")
        
        # Проверка подозрительных строк
        strings = self._extract_strings()
        suspicious_strings = [
            'http://', 'https://', 'ftp://', 'cmd.exe', 'powershell',
            'reg add', 'net user', 'taskkill', 'shutdown'
        ]
        
        for string in strings:
            for suspicious_str in suspicious_strings:
                if suspicious_str.lower() in string.lower():
                    suspicious.append(f"Suspicious string: {string[:50]}...")
                    break
        
        print_success(f"Найдено подозрительных особенностей: {len(suspicious)}")
        return suspicious

class YaraScanner:
    """YARA сканер для обнаружения вредоносного ПО"""
    
    def __init__(self):
        self.rules = []
        self.load_default_rules()
    
    def load_default_rules(self):
        """Загрузка стандартных правил YARA"""
        # Простые правила для демонстрации
        self.rules = [
            """
            rule SuspiciousPE {
                meta:
                    description = "Suspicious PE file characteristics"
                strings:
                    $s1 = "VirtualAlloc" ascii
                    $s2 = "CreateProcess" ascii
                    $s3 = "WriteProcessMemory" ascii
                condition:
                    2 of them
            }
            """,
            """
            rule NetworkActivity {
                meta:
                    description = "Network activity indicators"
                strings:
                    $s1 = "http://" ascii
                    $s2 = "https://" ascii
                    $s3 = "ftp://" ascii
                    $s4 = "socket" ascii
                condition:
                    2 of them
            }
            """,
            """
            rule RegistryModification {
                meta:
                    description = "Registry modification indicators"
                strings:
                    $s1 = "reg add" ascii
                    $s2 = "RegSetValue" ascii
                    $s3 = "HKEY_" ascii
                condition:
                    2 of them
            }
            """
        ]
    
    def scan_file(self, filepath: str) -> List[Dict]:
        """Сканирование файла с помощью YARA правил"""
        if not YARA_AVAILABLE:
            print_error("YARA сканирование недоступно - установите yara-python")
            return []
            
        print_info(f"YARA сканирование: {filepath}")
        
        matches = []
        
        try:
            for i, rule_text in enumerate(self.rules):
                try:
                    rule = yara.compile(source=rule_text)
                    matches_found = rule.match(filepath)
                    
                    for match in matches_found:
                        match_info = {
                            'rule_name': match.rule,
                            'rule_description': match.meta.get('description', 'No description'),
                            'matched_strings': [str(s) for s in match.strings],
                            'file': filepath
                        }
                        matches.append(match_info)
                        print_warning(f"YARA match: {match.rule}")
                
                except Exception as e:
                    print_error(f"Ошибка компиляции правила {i}: {e}")
        
        except Exception as e:
            print_error(f"Ошибка YARA сканирования: {e}")
        
        print_success(f"YARA сканирование завершено. Найдено совпадений: {len(matches)}")
        return matches

class BehaviorAnalyzer:
    """Анализатор поведения (симуляция)"""
    
    def __init__(self):
        self.behavior_patterns = {
            'file_operations': [
                'CreateFile', 'WriteFile', 'DeleteFile', 'MoveFile',
                'CopyFile', 'FindFirstFile', 'FindNextFile'
            ],
            'registry_operations': [
                'RegCreateKey', 'RegSetValue', 'RegDeleteKey',
                'RegOpenKey', 'RegQueryValue'
            ],
            'network_operations': [
                'socket', 'connect', 'send', 'recv', 'bind', 'listen',
                'InternetOpen', 'InternetConnect', 'HttpSendRequest'
            ],
            'process_operations': [
                'CreateProcess', 'OpenProcess', 'TerminateProcess',
                'CreateThread', 'SuspendThread', 'ResumeThread'
            ],
            'memory_operations': [
                'VirtualAlloc', 'VirtualFree', 'VirtualProtect',
                'WriteProcessMemory', 'ReadProcessMemory'
            ]
        }
    
    def analyze_behavior(self, filepath: str) -> Dict:
        """Анализ поведения файла"""
        print_info(f"Анализ поведения: {filepath}")
        
        # Извлекаем строки для анализа
        strings = self._extract_strings(filepath)
        
        behavior_analysis = {
            'file_operations': self._detect_patterns(strings, self.behavior_patterns['file_operations']),
            'registry_operations': self._detect_patterns(strings, self.behavior_patterns['registry_operations']),
            'network_operations': self._detect_patterns(strings, self.behavior_patterns['network_operations']),
            'process_operations': self._detect_patterns(strings, self.behavior_patterns['process_operations']),
            'memory_operations': self._detect_patterns(strings, self.behavior_patterns['memory_operations']),
            'risk_score': 0
        }
        
        # Вычисляем риск-скор
        risk_score = 0
        for category, patterns in behavior_analysis.items():
            if category != 'risk_score' and patterns:
                risk_score += len(patterns) * 10
        
        behavior_analysis['risk_score'] = min(risk_score, 100)
        
        print_success(f"Анализ поведения завершен. Риск-скор: {behavior_analysis['risk_score']}")
        return behavior_analysis
    
    def _extract_strings(self, filepath: str, min_length: int = 4) -> List[str]:
        """Извлечение строк из файла"""
        strings = []
        
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            current_string = ""
            for byte in data:
                if 32 <= byte <= 126:
                    current_string += chr(byte)
                else:
                    if len(current_string) >= min_length:
                        strings.append(current_string)
                    current_string = ""
            
            if len(current_string) >= min_length:
                strings.append(current_string)
        
        except Exception as e:
            print_error(f"Ошибка извлечения строк: {e}")
        
        return strings
    
    def _detect_patterns(self, strings: List[str], patterns: List[str]) -> List[str]:
        """Обнаружение паттернов в строках"""
        found_patterns = []
        
        for string in strings:
            for pattern in patterns:
                if pattern.lower() in string.lower():
                    found_patterns.append(string)
                    break
        
        return found_patterns

class MalwareAnalyzer:
    """Основной анализатор вредоносного ПО"""
    
    def __init__(self):
        self.pe_analyzer = None
        self.yara_scanner = YaraScanner()
        self.behavior_analyzer = BehaviorAnalyzer()
    
    def analyze_file(self, filepath: str) -> Dict:
        """Полный анализ файла"""
        print_warning(f"⚠️  АНАЛИЗ ВРЕДОНОСНОГО ПО - ТОЛЬКО ДЛЯ CTF!")
        print_info(f"Анализ файла: {filepath}")
        
        analysis_result = {
            'filepath': filepath,
            'timestamp': datetime.now().isoformat(),
            'file_hashes': self._calculate_hashes(filepath),
            'pe_analysis': {},
            'yara_scan': [],
            'behavior_analysis': {},
            'overall_risk': 0
        }
        
        # PE анализ
        try:
            self.pe_analyzer = PEAnalyzer(filepath)
            analysis_result['pe_analysis'] = self.pe_analyzer.analyze_pe()
        except Exception as e:
            print_error(f"PE анализ недоступен: {e}")
        
        # YARA сканирование
        try:
            analysis_result['yara_scan'] = self.yara_scanner.scan_file(filepath)
        except Exception as e:
            print_error(f"YARA сканирование недоступно: {e}")
        
        # Анализ поведения
        try:
            analysis_result['behavior_analysis'] = self.behavior_analyzer.analyze_behavior(filepath)
        except Exception as e:
            print_error(f"Анализ поведения недоступен: {e}")
        
        # Вычисление общего риска
        risk_factors = []
        
        if analysis_result['pe_analysis'].get('suspicious_features'):
            risk_factors.append(len(analysis_result['pe_analysis']['suspicious_features']) * 15)
        
        if analysis_result['yara_scan']:
            risk_factors.append(len(analysis_result['yara_scan']) * 20)
        
        if analysis_result['behavior_analysis'].get('risk_score'):
            risk_factors.append(analysis_result['behavior_analysis']['risk_score'])
        
        analysis_result['overall_risk'] = min(sum(risk_factors), 100)
        
        print_success(f"Анализ завершен. Общий риск: {analysis_result['overall_risk']}%")
        return analysis_result
    
    def _calculate_hashes(self, filepath: str) -> Dict:
        """Вычисление хешей файла"""
        hashes = {}
        
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
            
        except Exception as e:
            print_error(f"Ошибка вычисления хешей: {e}")
        
        return hashes

def main():
    parser = argparse.ArgumentParser(description='Malware Analysis Tools - ТОЛЬКО ДЛЯ CTF!')
    parser.add_argument('--file', required=True, help='Путь к файлу для анализа')
    parser.add_argument('--pe-only', action='store_true', help='Только PE анализ')
    parser.add_argument('--yara-only', action='store_true', help='Только YARA сканирование')
    parser.add_argument('--behavior-only', action='store_true', help='Только анализ поведения')
    parser.add_argument('--save', action='store_true', help='Сохранить результаты')
    
    args = parser.parse_args()
    
    # Предупреждение
    print_warning("⚠️  АНАЛИЗ ВРЕДОНОСНОГО ПО - ТОЛЬКО ДЛЯ CTF И ОБРАЗОВАНИЯ!")
    print_warning("⚠️  НЕ ИСПОЛЬЗУЙТЕ ДЛЯ НЕЗАКОННЫХ ЦЕЛЕЙ!")
    print()
    
    analyzer = MalwareAnalyzer()
    results = []
    
    if args.pe_only:
        # Только PE анализ
        try:
            pe_analyzer = PEAnalyzer(args.file)
            result = pe_analyzer.analyze_pe()
            results.append({'type': 'pe_analysis', 'result': result})
        except Exception as e:
            print_error(f"Ошибка PE анализа: {e}")
    
    elif args.yara_only:
        # Только YARA сканирование
        try:
            yara_scanner = YaraScanner()
            result = yara_scanner.scan_file(args.file)
            results.append({'type': 'yara_scan', 'result': result})
        except Exception as e:
            print_error(f"Ошибка YARA сканирования: {e}")
    
    elif args.behavior_only:
        # Только анализ поведения
        try:
            behavior_analyzer = BehaviorAnalyzer()
            result = behavior_analyzer.analyze_behavior(args.file)
            results.append({'type': 'behavior_analysis', 'result': result})
        except Exception as e:
            print_error(f"Ошибка анализа поведения: {e}")
    
    else:
        # Полный анализ
        try:
            result = analyzer.analyze_file(args.file)
            results.append({'type': 'full_analysis', 'result': result})
        except Exception as e:
            print_error(f"Ошибка полного анализа: {e}")
    
    # Вывод результатов
    print(f"\n{Colors.HEADER}{'=' * 60}{Colors.RESET}")
    print_success(f"Выполнено анализов: {len(results)}")
    
    for result in results:
        if result['type'] == 'full_analysis':
            analysis = result['result']
            print_info(f"Файл: {analysis['filepath']}")
            print_info(f"Общий риск: {analysis['overall_risk']}%")
            print_info(f"Хеш MD5: {analysis['file_hashes'].get('md5', 'N/A')}")
            print_info(f"Подозрительные особенности: {len(analysis['pe_analysis'].get('suspicious_features', []))}")
            print_info(f"YARA совпадений: {len(analysis['yara_scan'])}")
        else:
            print_info(f"{result['type']}: завершен")
    
    if args.save and results:
        save_results(results, "malware_analysis", "json")
    
    print_warning("\n⚠️  ПОМНИТЕ: Используйте только для легальных CTF и образования!")

if __name__ == "__main__":
    import math
    main()
